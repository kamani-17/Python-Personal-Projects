#Chess Game Buil

#Step 1 create an 8x8 board - last time we did this we had an issue so hopefully this time it will work, success here is defining variables and using them to create a board, creating necessary loops and ensuring the board is the correct size, key to also test along the way and leave that in the code be it hide it or not (done 3 times)

def make_piece(color, kind):
# this here allows me to define the 2 variables of interest - color of chess pieces and chess pieces kind (or types)
    return {"color": color, "kind": kind}
#this line here does 2 things - it provides gives the 2 varbailes in def make_piece values and allows for them to be labelled, the curly brackets also ensure it is a dictionary we are calling/using

'''print(make_piece("white", "pawn"))
# this line here calls the function and provides the values for the variables - a test to see if it works

print(type(make_piece("color", "kind")))
# this line here calls the return type of the function - a test to see if it works - illustrates that it is a dictionary'''

board = [[None for _ in range(8)] for _ in range(8)]
# no pieces on the board yet - 8x8 board, this line also allows us to avoid using a for loop to create the board - the none part means row 2 through the 5 are empty

back_row = ["rook", "knight", "bishop", "queen", "king", "bishop", "knight", "rook"]
for col in range(8): 
    board[0][col] = make_piece("black", back_row[col])
    board[1][col] = make_piece("black", "pawn")
# here we are defining the black pieces and their positions on the board - the for loop allows us to do this without having to write out each piece and its position

    board[6][col] = make_piece("white", "pawn")
    board[7][col] = make_piece("white", back_row[col])
# here we are defining the white pieces and their positions on the board - the for loop allows us to do this without having to write out each piece and its position

'''pawn_count = 0

for row in board:
    for square in row:
        if square is not None and square['kind'] == 'pawn':
            pawn_count += 1

print(f"Number of pawns on the board: {pawn_count}")

# above is a sense check to count how many pawn pieces are on the borard  - should be 16, my understanding is that the first for loop is for each row and the secod for loop is for each sqaure in the row (no need to column search). There was an initial error in the if part where it was "type" rather than "kind". Our definition of make_piece is a dictionary, so we need to call the key "kind" to get the value "pawn"'''





#Step 2 - allow players to enter moves and update the board (chess notation such as e2 e4, make it case sensitive), convert moves to board coordinates, so row and column numbers, move the piece to the desired sqaure - note checking if move is valid or not is a Step 3 action. 

move = input("Enter your move (e.g., E2 E4): ")
# this line here allows the user to enter a move in chess notation]

start_square, end_square = move.split()
# was a bit lost at first but this line here splits the move into 2 parts - the start square and the end square

'''print (start_square, end_square)
# quick sense check really to see if the split worked - to help capture moves'''

start_row = 8 - int(start_square[1])
start_col = ord(start_square[0].lower()) - ord('a')

end_row = 8 - int(end_square[1])
end_col = ord(end_square[0].lower()) - ord('a')

board[end_row][end_col] = board[start_row][start_col]
board[start_row][start_col] = None
